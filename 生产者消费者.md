```
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import itertools 
import threading
import signal
from boto3.session import Session
from botocore.config import Config as boto3Config
from Queue import Queue

class Producer(threading.Thread):
    def run(self):
        global count
        global queue
        global is_exit
        session_src = Session("eos", "eos")
        src_bucket = "source"
        client_src = session_src.client('s3', endpoint_url="http://10.128.3.68",
                                        config=boto3Config(connect_timeout=5,
                                                           retries={'max_attempts': 5}))

        paginator = client_src.get_paginator('list_objects')
        page_iterator = paginator.paginate(Bucket=src_bucket)
        for page in page_iterator:
            for item in page['Contents']:
                if cond.acquire():
                    if is_exit:  # 每次获取锁之后，先检查全局状态变量
                        cond.notifyAll()  # 退出前必须唤醒其他所有线程
                        cond.release()  # 退出前必须释放锁
                        break
                    if count > 1000:
                        cond.wait()
                    else:
                        print "put ", item['Key'], " into Queue"
                        queue.put(item['Key'])
                        count = count + 1
                        cond.notify()
                    cond.release()
        is_exit = True
        print "Producer run exit"
                
class Consumer(threading.Thread):
    def run(self):
        global count
        global queue
        global is_exit
        while True:
            if cond.acquire():
                if is_exit and queue.empty():
                    cond.notifyAll()
                    cond.release()
                    break
                if count < 1:
                    cond.wait()
                else:
                    count = count - 1
                    print "%s consume key=%s" % (self.name, queue.get())
                    cond.notify()
                cond.release()
        print "%s Consumer run exit" % (self.name, )
count = 0
queue = Queue(maxsize=1000)
cond = threading.Condition()
is_exit = False #全局变量
def signal_handler(signum, frame): #信号处理函数
    global is_exit
    is_exit = True #主线程信号处理函数修改全局变量，提示子线程退出
    print "Get signal, set is_exit = True"
def test():
    producers = []
    consumers = []
    for i in xrange(1):
        p = Producer()
        producers.append(p)
        p.setDaemon(True) #子线程daemon
        p.start()
    for j in xrange(200):
        c = Consumer()
        consumers.append(c)
        c.setDaemon(True) #子线程daemon
        c.start()
    while 1:
        alive = False
        for t in itertools.chain(producers, consumers): #循环检查所有子线程
            alive = alive or t.isAlive() #保证所有子线程退出
        if not alive:
            break
if __name__ == "__main__":
    signal.signal(signal.SIGINT, signal_handler) #注册信号处理函数
    signal.signal(signal.SIGTERM, signal_handler) #注册信号处理函数
    test()

```
